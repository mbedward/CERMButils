#' Sample date-time values from fire progression polygons
#'
#' @param prog An \code{sf} spatial data frame of fire progression polygons. The
#'   data must have a coordinate reference system defined and the progression
#'   polygons must not overlap (both of these conditions will be checked).
#'
#' @param datetimecol (character) The name of the column in the input
#'   \code{progressions} data frame with date-time values. The date-times must
#'   be \code{POSIX} values (e.g. class \code{POSIX.ct}).
#'
#' @param sampline An \code{sf} spatial data frame of sampling lines as
#'   generated by function \code{make_sample_lines}.
#'
#' @param sampline_idcols (character) The name of one or more columns that
#'   identify each sample line and that should be copied from the sample lines
#'   layer to the output data frame. Defaults to \code{c("refid", "line_index",
#'   "segment")} which are the column names used by function \code{make_sample_lines()}.
#'
#' @return Either an \code{sf} spatial data frame with \code{LINESTRING}
#'   geometry if argument \code{return_geom} is \code{TRUE}, or a plain data
#'   frame if \code{return_geom} is \code{FALSE}. Each record corresponds to a
#'   line segment (part or whole of a sample line) that either intersects a
#'   progression polygon or is outside any polygons. Other columns are the
#'   sample line ID attributes, progression date-time, segment distance
#'   (distance from start of sample line), and segment length.
#'
#' @seealso \code{\link{make_sample_lines}}
#'
#' @examples
#' \dontrun{
#' library(CERMButils)
#' library(sf)
#'
#' # Load a layer of back-burning lines and generate sample lines with the
#' # desired maximum length and spacing
#' dat_bb <- st_read("path/to/bb_lines")
#' dat_slines <- make_sample_lines(dat_bb, bb_id = "OBJECTID", trim_by = "all")
#'
#' # Load a corresponding layer of fire progression polygons and get
#' # the date-time value(s), and possibly gaps of no data, along each sample line
#' dat_prog <- st_read("path/to/progressions")
#'
#' dat_prog_samples <- get_progression_times(dat_prog,
#'                                           datetimecol = "LASTTIME",
#'                                           dat_slines)
#' }
#'
#' @export
#
get_progression_times <- function(prog,
                                  datetimecol,
                                  sampline,
                                  sampline_idcols = c("refid", "line_index", "segment"),
                                  return_geom = TRUE) {

  checkmate::assert_class(prog, "sf")

  if (!all(sf::st_geometry_type(prog) %in% c("POLYGON", "MULTIPOLYGON"))) {
    stop("All progression features must be either POLYGON or MULTIPOLYGON geometries")
  }

  CRSprog <- sf::st_crs(prog)
  if (is.na(CRSprog)) stop("A cooordinate reference system must be set for the progression layer")

  # Ensure that the name of the geometry column is 'geom' to make the code for
  # later steps a bit less fiddly
  sf::st_geometry(prog) <- "geom"

  # Check progression date-time col is properly specified
  checkmate::assert_string(datetimecol, min.chars = 1)
  if (!(datetimecol %in% colnames(prog))) {
    msg <- glue::glue("The specified time column {datetimecol} is not in the progressions data")
    stop(msg)
  }

  # Check the type and format of the data-time values
  checkmate::check_class(prog[[datetimecol]], classes = c("POSIX.t"))

  # Check sample lines layer
  checkmate::assert_class(sampline, "sf")

  if (!all(sf::st_geometry_type(sampline) == "LINESTRING")) {
    stop("All sample lines must have geometry type LINESTRING")
  }

  # Check sample line IDs are properly specified
  checkmate::assert_character(sampline_idcols, any.missing = FALSE, min.len = 1)

  ok <- sampline_idcols %in% colnames(sampline)
  if (!all(ok)) {
    msg <- paste(sampline_idcols[!ok], collapse = ", ")
    msg <- glue::glue("Missing specified ID column(s) in the sample lines data: {msg}")
    stop(msg)
  }

  CRSsampline <- sf::st_crs(sampline)
  if (is.na(CRSsampline)) stop("A coordinate reference system must be set for the sample lines")

  # Reproject the sample lines as required
  if (CRSsampline != CRSprog) sampline <- sf::st_transform(sampline, CRSprog)

  # Process each sample line
  lnids <- sf::st_drop_geometry(sampline) %>%
    dplyr::select(dplyr::all_of(sampline_idcols))

  res <- lapply(seq_len(nrow(sampline)), function(iline) {
    ln <- sf::st_geometry(sampline[iline, ])

    # Identify intersecting progression polygons
    ii <- unlist( st_intersects(ln, prog) )

    if (length(ii) == 0) {
      # Line does not intersect any polygons. Treat it all as 'outside'
      res <- sf::st_sf(.datetime__ = NA, geom = sf::st_sfc(ln))
      sf::st_crs(res) <- sf::st_crs(prog)
      colnames(res)[1] <- datetimecol

    } else {
      # Line intersects at least one polygon. Identify inside and outside segments.
      #
      # Inside segment(s)
      res <- suppressWarnings({
        sf::st_intersection(prog[ii,], ln) %>%
          dplyr::select(dplyr::all_of(datetimecol))
      })

      # Outside segment(s)
      outside <- sf::st_difference(ln, sf::st_union(prog[ii,]))

      # If there were any outside segments, combine these with the inside segments.
      # Note: the 'sf' help doc for st_difference implies that 'outside' should be
      # a list (I think)
      #
      if (length(outside) > 0) {
        # outside will either be a LINESTRING (if only one segment) or a MULTILINESTRING.
        # Do a cast to ensure we know what we are dealing with.
        #
        # Note: if a MULTILINESTRING, we have to first wrap it in a geometry list
        # with st_sfc (see https://gis.stackexchange.com/a/257436/59514).
        # That will also be safe if outside is just a LINESTRING.
        #
        outside <- sf::st_cast(sf::st_sfc(outside), "LINESTRING")

        dat_outside <- sf::st_sf(.datetime__ = NA, geom = outside)
        colnames(dat_outside)[1] <- datetimecol

        res <- rbind(res, dat_outside)
      }
    }

    # Add ID columns
    res <- dplyr::bind_cols(res, lnids[iline,])

    # Order sample line segments by distance from the start of the line
    p0 <- lwgeom::st_startpoint(ln)
    d <- as.numeric( sf::st_distance(p0, res) )

    # Sometimes d is a matrix of distances (despite help docs saying otherwise).
    # Ensure it is a vector and then get the order statistics.
    d <- c(d)
    o <- order(d)

    res <- res[o, ]

    # Add columns for distance from start of sampling line and line segment length
    res$segment_distance <- d[o]
    res$segment_length <- as.numeric(sf::st_length(res))

    if (return_geom) {
      # Put geometry column last
      res <- dplyr::select(res, dplyr::everything(), geom)
    } else {
      res <- sf::st_drop_geometry(res)
    }

    rownames(res) <- NULL

    res
  })


  res <- do.call(rbind, res)

  res <- res %>%
    dplyr::select(dplyr::all_of(sampline_idcols), dplyr::all_of(datetimecol), dplyr::everything())

  res
}


#' Generate sampling lines across back-burning line features
#'
#' Given a set of input line features representing back-burning lines, this
#' function places sample lines at regular intervals along each input feature,
#' perpendicular to the local feature angle. The orientation of each sampling
#' line is set such that it is orthogonal to a smoothed version of the
#' back-burning line to minimize the influence of any local kinks and turns in
#' the back-burning line. Sample lines are located at, and either side of, the
#' mid-point of each input feature. In cases where a back-burning line is curved
#' or convoluted it is possible for a sampling line from one section to approach
#' or cross another section. It is also possible that the sampling line might
#' approach other back-burning lines. The \code{trim_by} argument can be used to
#' avoid such occurrences. Setting \code{trim_by} to \code{'parent'} will cause
#' sampling lines to be trimmed to avoid re-approaching the parent back-burning
#' line; while setting it to \code{'all'} will trim sampling lines based on
#' their distance to both the parent and other back-burning lines.
#'
#' @param bb_lines An \code{sf} spatial data frame containing one or more line
#'   features representing back-burning lines. The data must have a coordinate
#'   reference system defined with metres as map units (e.g. NSW Lambert/GDA94
#'   EPSG:3308).
#'
#' @param bb_id (character; default "OID") The name of a column in the
#'   \code{bb_lines} data frame that uniquely identifies back-burning line
#'   features.
#'
#' @param line_spacing A single numeric value for the distance in metres
#'   between sampling lines along each back-burning line feature.
#'
#' @param line_half_length A single numeric value specifying the maximum
#'   distance in metres that a sampling line will extend on either side of the
#'   back-burning line.
#'
#' @param point_spacing A single numeric value specifying the uniform distance
#'   between sample points along each sampling line. The first point is always
#'   positioned at the intersection of the sampling line and the reference
#'   back-burning line.
#'
#' @param trim_by (character) One of \code{('all', 'parent', 'none')}. May be
#'   abbreviated. If \code{'all'} (default), each sample point must lie at a
#'   greater distance to all back-burning lines than the preceding point AND
#'   must be closer to the parent back-burning line than any other; if
#'   \code{'parent'}, a similar increasing distance rule is applied but only in
#'   relation to the parent back-burning line that the sample points are
#'   associated with; if \code{'none'}, no distance rule applies.
#'
#' @param out_epsg Integer EPSG code specifying the map projection for the
#'   output progression polygons. This \emph{must} be a projected coordinate
#'   system with metres as map units. The default is 8058 (NSW Lambert /
#'   GDA2020).
#'
#' @param smoothing_bw A single numeric value for the bandwidth (metres) of the
#'   Gaussian kernel filter used to smooth each back-burning feature. The
#'   default value of 1000m seems to give good results.
#'
#' @return An \code{sf} spatial data frame of sample point features with the
#'   following columns:
#'
#'   \code{refid} Identifier of the input back-burning line feature that a point
#'   is sampling, with values taken from the input data column specified by the
#'   \code{bb_id} argument.
#'
#'   \code{line_index} Integer index (from 1) of the sampling lines within a
#'   given back-burning line.
#'
#'   \code{segment} Either \code{'L'} or \code{'R'} indicating the position of
#'   the sampling line on the left or right of the back-burning line. Note that
#'   left and right, as used here, are simply relative to the digitizing
#'   direction (i.e. order of vertices) of the back-burning line.
#'
#'   \code{geom} The feature geometry (\code{LINESTRING}).
#'
#' @seealso \code{\link{get_progression_times}}
#'
#' @examples
#' \dontrun{
#' libary(CERMButils)
#' library(sf)
#'
#' # Load back-burning line features from a GeoPackage layer, shapefile etc.
#' dat_bb <- st_read(...)
#'
#' # Generate sampling lines at 1km intervals along each # back-burning line.
#' # Sampling lines extend up to 5km either side of the back-burning line but
#' # will be trimmed to avoid the line approaching the parent or other
#' # back-burning lines too closely.
#' #
#' dat_sample_points <- make_sample_points(bb,
#'                                         line_spacing = 1000,
#'                                         line_half_length = 5000,
#'                                         trim_by = "all")
#' }
#'
#' @export
#
make_sample_lines <- function(bb_lines,
                              bb_id = "OID",
                              line_spacing = 1000,
                              line_half_length = 5000,
                              trim_by = c("all", "parent", "none"),
                              out_epsg = 8058,
                              smoothing_bw = 1000) {

  checkmate::assert_class(bb_lines, "sf")

  CRS <- sf::st_crs(bb_lines)
  if (is.na(CRS)) stop("A cooordinate reference system must be set for the back-burning line features")

  checkmate::assert_string(bb_id, min.chars = 1)
  if (!(bb_id %in% colnames(bb_lines))) {
    msg <- glue::glue("The value of argument bb_id {bb_id} is not a column in the input line features data frame")
    stop(msg)
  }

  # Line IDs must be unique
  num_ids <- length(unique(bb_lines[[bb_id]]))
  if (num_ids != nrow(bb_lines)) {
    msg <- glue::glue("The values of the specified ID column {bb_id} are not all unique")
    stop(msg)
  }

  checkmate::assert_number(line_spacing, finite = TRUE, lower = 1)
  checkmate::assert_number(line_half_length, finite = TRUE, lower = 1)

  trim_by = match.arg(trim_by)

  # Check that the output CRS is defined and has metres as map units
  checkmate::assert_integerish(out_epsg, any.missing = FALSE, len = 1)

  units_txt <- units::deparse_unit(sf::st_crs(out_epsg)$ud_unit)
  if (!units_txt == "m") {
    msg <- glue::glue("Argument out_epsg ({out_epsg}) does not have metres as map units")
    stop(msg)
  }

  checkmate::assert_number(smoothing_bw, finite = TRUE, lower = 1)

  # Re-project the input back-burning lines layer to the output projection if required
  bb_lines <- sf::st_transform(bb_lines, out_epsg)

  # Attempt to fix any invalid geometries
  bb_lines <- sf::st_make_valid(bb_lines)


  # Constant used to position the points that will be placed along each
  # sampling line segment to check distance to parent and/or other back-burning
  # lines.
  POINTS_PER_SEGMENT <- 101  # includes origin of each segment


  # Generate initial sampling lines
  #
  res <- lapply(seq_len(nrow(bb_lines)), function(line_index) {

    # Get the identifier for this line feature
    FeatureID <- bb_lines[[bb_id]][line_index]

    # Get the line feature and densify its vertices
    g <- sf::st_geometry(bb_lines[line_index, ])

    # Prepare a smoothed version of the line feature using Gaussian kernel smoothing
    gsmooth <- smoothr::smooth(g, method = "ksmooth", bandwidth = smoothing_bw)

    # Densify the vertices of the original and smoothed features
    VertexDistance <- 1.0
    g <- smoothr::smooth(g, method = "densify", max_distance = VertexDistance)
    gsmooth <- smoothr::smooth(gsmooth, method = "densify", max_distance = VertexDistance)

    # Convert the smoothed feature to a point set. This makes querying the step
    # points a little easier.
    #gsmooth_points <- sf::st_cast(gsmooth, "POINT")
    gsmooth_vertices <- sf::st_coordinates(gsmooth)[, 1:2]

    vs <- sf::st_coordinates(g)[, 1:2]
    d <- sapply( seq_len(nrow(vs)-1), function(k) sqrt(sum((vs[k,] - vs[k+1,])^2)) )
    d <- c(0, cumsum(d))

    # Locate the vertex closest to the middle of the feature
    dmax <- max(d)
    imid <- which.min( abs(d - dmax/2) )

    # It's just a jump to the left...
    step_points <- icur <- imid
    repeat {
      dtarget <- d[icur] - line_spacing
      if (dtarget > line_spacing/2 + VertexDistance) {
        icur <- which.min(abs(d - dtarget))
        step_points <- c(step_points, icur)
      } else {
        break
      }
    }

    # ...and then a jump to the right
    icur <- imid
    repeat {
      dtarget <- d[icur] + line_spacing
      if (dtarget < dmax - (line_spacing/2 + VertexDistance)) {
        icur <- which.min(abs(d - dtarget))
        step_points <- c(step_points, icur)
      } else {
        break
      }
    }

    # Get step vertices, ordered by the direction of back-burning line vertices
    step_points <- sort(step_points)
    step_vertices <- vs[step_points, , drop=FALSE]

    # Create the pair of sample line segments at each step vertex, either side
    # of the back-burning line
    sample_lines <- lapply(seq_len(length(step_points)), function(istep) {
      vcur <- step_vertices[istep, ]

      # Use the nearest vertices from the smoothed line feature
      # to set the angle of the normal vector at the current step.
      dsmooth2 <- apply(gsmooth_vertices, 1, function(vxy) sum((vxy - vcur)^2))
      inear <- which.min(dsmooth2)

      ibefore <- max(inear-1, 1)
      p0 <- gsmooth_vertices[ibefore, ]

      iafter <- min(inear+1, nrow(gsmooth_vertices))
      p1 <- gsmooth_vertices[iafter, ]

      dxy <- p1 - p0
      len <- sqrt(sum(dxy^2))
      lenfac <- line_half_length / len

      pnorm1 <- vcur + c(dxy[2], -dxy[1]) * lenfac
      pnorm2 <- vcur + c(-dxy[2], dxy[1]) * lenfac

      left_seg <- sf::st_linestring(rbind(vcur, pnorm1))
      right_seg <- sf::st_linestring(rbind(vcur, pnorm2))

      # Geom list with the two line segments, labelled 'R' (right) and
      # 'L' (left) relative to the order of vertices of the target feature
      segments <- sf::st_sfc(left_seg, right_seg, crs = out_epsg)
      sf::st_sf(refid = FeatureID, line_index = istep, segment = c('R', 'L'), geom = segments)
    })

    do.call(rbind, sample_lines)
  })

  # Combine sets of sample lines into a single sf data frame
  dat_sample_lines <- do.call(rbind, res)

  # Also give each sample line a supplementary identifier to make line checking and
  # trimming (see below) a bit easier

  dat_sample_lines <- dat_sample_lines %>%
    dplyr::mutate(segment_id = sprintf("%s:%s:%s", refid, line_index, segment))

  # Attributes for client code use
  attr(dat_sample_lines, "line_spacing") <- line_spacing
  attr(dat_sample_lines, "line_half_length") <- line_half_length


  # If requested, check along each sampling line to make sure that we are not
  # getting closer to the parent and/or other back-burning lines at any point,
  # and trim sampling lines as required.
  #
  if (trim_by != "none") {
    # Generate regularly spaced points along each sampling line to use for
    # checking that the line is not getting closer to the parent back-burning
    # line, and optionally any other back-burning line, at some point.

    # Point positions expressed as fractions of line segment length
    point_spacing <- line_half_length / (POINTS_PER_SEGMENT-1)
    dpos <- seq(0.0, 1.0, length.out = POINTS_PER_SEGMENT)

    # This will return a geometry list of MULTIPOINT objects: one per line segment
    gpoints <- sf::st_line_sample(dat_sample_lines, sample = dpos)

    # Attribute points with back-burning feature ID and sample line values
    dat_points <- dat_sample_lines
    sf::st_geometry(dat_points) <- gpoints

    # Convert from multi-point to single point features
    dat_points <- suppressWarnings({
      sf::st_cast(dat_points, "POINT")
    })

    # Cumulative distance along the line segment for each point.
    dat_points <- dat_points %>%
      dplyr::group_by(across(c(segment_id, refid, line_index, segment))) %>%

      dplyr::mutate(point_index = dplyr::row_number(),
                    dist_line = (point_index-1) * point_spacing) %>%

      dplyr::ungroup() %>%
      dplyr::select(-point_index)

    # Shortest distance of each point to the parent back-burning line.
    # This can be less than 'dist_line' (calculated above) if the parent line
    # is wiggly.
    dat_points$dist_parent <- NA_real_
    for (xid in unique(bb_lines[[bb_id]])) {
      ibb <- bb_lines[[bb_id]] == xid
      ipoints <- dat_points$refid == xid
      dat_points$dist_parent[ipoints] <- as.numeric( sf::st_distance(dat_points[ipoints, ], bb_lines[ibb, ]) )
    }

    dat_points$dist_parent <- zapsmall(dat_points$dist_parent)

    # Shortest distance to *any* back-burning line (i.e. not just the parent)
    # required if filtering points on all distances.
    #
    if (trim_by == 'all') {
      dat_points$dist_all <- NA_real_

      for (xid in unique(bb_lines[[bb_id]])) {
        ibb <- bb_lines[[bb_id]] == xid
        ipoints <- dat_points$refid == xid

        # Find any other lines that are close enough to the parent line to
        # be relevant for point distances (trying to reduce run time)
        #
        xbuf <- sf::st_buffer(bb_lines[ibb, ], dist = 2 * line_half_length)
        xi <- which( lengths(sf::st_intersects(bb_lines, xbuf)) > 0)

        d <- sf::st_distance(dat_points[ipoints, ], bb_lines[xi, ])  # matrix where ncol = number of relevant bb lines
        d <- apply(d, MARGIN = 1, min)
        dat_points$dist_all[ipoints] <- as.numeric(d)
      }

      dat_points$dist_all <- zapsmall(dat_points$dist_all)
    }

    # Function to check the distance values of points along an individual sample
    # line segment. Returns a logical vector indicating which points are valid
    # (i.e. not getting closer to the parent and/or other back-burning lines).
    #
    # The function is called with either one or two vectors of point distances.
    # If only considering the parent back-burning line, it is called with just
    # the `dparent` argument (point distances to parent line). If also considering
    # other back-burning lines, the second argument `dall` is provided.
    #
    # See usage in the dplyr pipeline immediately below the function definition.
    #
    fn_keep <- function(dparent, dall = NULL) {
      n <- length(dparent)
      delta_parent <- diff(dparent)
      keep <- c(TRUE, delta_parent > 0)  # Note: this will work even if length(d) < 2 so no deltas

      if (!is.null(dall)) {  # considering both distance to parent and other features
        delta_all <- diff(dall)
        keep <- keep & c(TRUE, delta_all > 0) & dall >= dparent
      }

      x <- which(!keep)
      if (length(x) > 0) keep[min(x):n] <- FALSE

      keep
    }

    dat_points <- dat_points %>%
      dplyr::group_by(across(c(segment_id, refid, line_index, segment)))

    if (trim_by == 'parent') {
      # Filter on values of distance to parent feature
      dat_points <- dplyr::mutate(dat_points, keep = fn_keep(dist_parent))
    } else {
      # Filter on values of distance to any feature
      dat_points <- dplyr::mutate(dat_points, keep = fn_keep(dist_parent, dist_all))
    }

    dat_points <- dat_points %>%
      dplyr::ungroup() %>%
      dplyr::filter(keep)


    dat_split_points <- dat_points %>%
      dplyr::group_by(segment_id) %>%

      # Subset to the furthest point that is not too close to parent and/or
      # other back-burning lines
      dplyr::filter(dist_line == max(dist_line)) %>%

      # Guard against lines where no points other than the origin were retained
      dplyr::filter(dist_line > 0) %>%

      dplyr::ungroup()

    # Filter the sample lines in case there were any that cannot be retained
    # because no safe split point could be defined
    dat_sample_lines <- dat_sample_lines %>%
      dplyr::filter(segment_id %in% dat_split_points$segment_id)

    # Ensure lines and split points are in the same order
    dat_split_points <- dplyr::arrange(dat_split_points, segment_id)
    dat_sample_lines <- dplyr::arrange(dat_sample_lines, segment_id)

    # Just in case
    stopifnot(nrow(dat_split_points) == nrow(dat_sample_lines))

    # Shorten each sampling line as required
    #
    gtrimmed <- lapply(seq_len(nrow(dat_sample_lines)), function(k) {
      gln <- sf::st_geometry(dat_sample_lines[k,])[[1]]
      gpt <- sf::st_geometry(dat_split_points[k,])[[1]]

      # using st_split is not reliable because limited numeric precision of
      # coordinates can make the point appear to be just off the line
      #res <- lwgeom::st_split(gln, gpt)

      p0 <- lwgeom::st_startpoint(gln)
      pts <- sf::st_union(p0, gpt)

      sf::st_cast(pts, "LINESTRING")
    })

    # gtrimmed will have been returned as a list of st_sfc lists
    gtrimmed <- do.call(c, gtrimmed)
    sf::st_crs(gtrimmed) <- out_epsg

    sf::st_geometry(dat_sample_lines) <- gtrimmed
  }

  # Return sampling lines with the temporary 'segment_id' column dropped
  dat_sample_lines %>%
    dplyr::select(-segment_id)
}

