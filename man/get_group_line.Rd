% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cleaning_functions.R
\name{get_group_line}
\alias{get_group_line}
\title{Derive an average line for a group of line features}
\usage{
get_group_line(lines, group_ids = NULL, buffer_dist = 25, progress = TRUE)
}
\arguments{
\item{lines}{An \code{'sf'} spatial data frame of input line features. This
must have a projected (i.e. non-geographic) coordinate reference system
assigned. All features should have single-part geometries; either type
\code{'LINESTRING'} or type \code{'MULTILINESTRING'} with one part.}

\item{group_ids}{An integer vector of group ID values with length equal to
the number of rows in the input \code{`sf`} data frame. The ID values do
not have to be consecutive.}

\item{buffer_dist}{The width of the buffer to place around each group of line
features to form the polygon from which a representative line will be
generated using the centreline algorithm.}
}
\value{
An \code{sf} data frame of \code{N} line features, where \code{N} is
  the number of distinct input group ID values.
  \describe{
  \item{id}{Integer group ID value}
  \item{maxdist}{The furthest distance between a member line in the group and
    the average line. This will always be zero for groups with only line.
    Large distance values indicate groups where the average line is possibly
    not representative of all lines in the group.
    }
  \item{geom}{The average line geometry}
  }
}
\description{
The purpose of this function is to reduce groups of similar line features to
a single average or representative line, where \emph{similar} means that all
lines in a group are closely located and have approximately the same
orientation along their length. The function takes an \code{sf} data frame of
line features and a vector of integer group ID values to identify which group
each line feature belongs to. A buffer polygon is placed around the unioned
lines in each group. An average line is then generated by taking the
centreline of the buffer polygon.
}
\details{
Group IDs will generally have been created using the
\code{assign_lines_to_groups()} function which presently only requires that
lines be with a certain distance of each other at some point. Hence, it is
possible for a group to contain lines that would not have been grouped
together by manual inspection, e.g. lines meeting at a T-junction. To help
identify such cases, the function calculates the furthest distance between a
point on any of the group lines and the derived average line and records this
in the \code{maxdist} column of the output \code{sf} data frame. The larger
this value, the higher the chance that the average line does not reliably
represent all lines in the group.

The value of the \code{buffer_dist} argument can greatly influence the result
of this function. In general, it seems to be best to use a fairly small value
for the buffer distance, relative to the average length of input line
features, to make it more likely that the buffer polygons placed around each
group of lines will be elongated. Polygons that are more circular or square
will usually result in representative lines that are unacceptable. Hopefully,
most such cases will be flagged for checking in the output data frame, but
beware of ones that slip through.
}
\examples{
\dontrun{
library(dplyr)
library(sf)
library(CERMButils)

ids <- assign_lines_to_groups(dat_firelines)
dat_group_lines <- get_group_line(dat_firelines, ids, buffer_dist = 25)

# Optionally, sort by the 'maxdist' column to identify any groups where the
# average line does not usefully represent the member lines.

dat_group_lines <- dat_group_lines \%>\%
  arrange(desc(maxdist))
}

}
